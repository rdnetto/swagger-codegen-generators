{-# OPTIONS_GHC -fno-warn-unused-binds -fno-warn-unused-imports -fno-warn-missing-signatures -freduction-depth=0 #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE ViewPatterns #-}

module {{title}}.Client (
    {{title}}ClientMonad(..),
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}
    {{operationId}},
{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
  ) where

import {{title}}.API
import {{title}}.Common
import {{title}}.Types

import Data.Coerce (coerce)
import qualified Data.Map as Map
import Data.Proxy (Proxy(..))
import Prelude
import Servant.API
import Servant.Client (ClientM, client, hoistClient)

{{#imports}}import {{.}}
{{/imports}}


{{#apiInfo}}
-- | Monads in which client calls may be embedded.
class Monad m => {{title}}ClientMonad m where
  lift{{title}}Client :: ClientM a -> m a


-- We generate the clients directly from the routes as a workaround for https://github.com/haskell-servant/servant/issues/986
{{#apis}}{{#operations}}{{#operation}}
{- | {{& notes}} -}
{{operationId}} :: {{title}}ClientMonad m => {{& vendorExtensions.x-clientType}}
{{operationId}} {{#vendorExtensions.x-clientArgNames}}x{{& @index}} {{/vendorExtensions.x-clientArgNames}} = {{operationId}}' {{#vendorExtensions.x-clientArgNames}}(coerce x{{& @index}}) {{/vendorExtensions.x-clientArgNames}} where
  {{operationId}}' = hoistClient proxy lift{{title}}Client (client proxy)
  proxy = Proxy :: Proxy {{& vendorExtensions.x-routeName}}

{{/operation}}{{/operations}}
{{/apis}}

{{/apiInfo}}

