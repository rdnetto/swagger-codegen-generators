{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE OverloadedLists #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE ViewPatterns #-}
{-# OPTIONS_GHC -fno-warn-unused-binds -fno-warn-unused-imports -freduction-depth=0 #-}

module {{title}}.Client where

import {{title}}.API
import {{title}}.Common
import {{title}}.Types

import Control.Monad.IO.Class
import Data.Aeson (Value)
import Data.Coerce (coerce)
import Data.Function ((&))
import qualified Data.Map as Map
import Data.Monoid ((<>))
import Data.Proxy (Proxy(..))
import Data.Text (Text)
import qualified Data.Text as T
import GHC.Exts (IsString(..))
import GHC.Generics (Generic)
import Network.HTTP.Client (Manager, defaultManagerSettings, newManager)
import Network.HTTP.Types.Method (methodOptions)
import qualified Network.Wai.Handler.Warp as Warp
import Servant (Handler, serve)
import Servant.API
import Servant.API.Verbs (StdMethod(..), Verb)
import Servant.Client (Scheme(Http), ServantError, ClientM, client, hoistClient)
import Servant.Client.Core.Internal.BaseUrl (BaseUrl(..))
import Web.Internal.FormUrlEncoded (ToForm(..), FromForm(..), parseUnique)


{{#apiInfo}}
newtype {{title}}Client a = {{title}}Client
  { runClient :: Manager -> BaseUrl -> ClientM a
  } deriving Functor

instance Applicative {{title}}Client where
  pure x = {{title}}Client (\_ _ -> pure x)
  ({{title}}Client f) <*> ({{title}}Client x) =
    {{title}}Client (\manager url -> f manager url <*> x manager url)

instance Monad {{title}}Client where
  ({{title}}Client a) >>= f =
    {{title}}Client (\manager url -> do
      value <- a manager url
      runClient (f value) manager url)

instance MonadIO {{title}}Client where
  liftIO io = {{title}}Client (\_ _ -> liftIO io)

liftClient :: ClientM a -> {{title}}Client a
liftClient clientM = {{title}}Client (\_ _ -> clientM)

create{{title}}Client :: {{title}}Backend {{title}}Client
create{{title}}Client = {{title}}Backend{..}
  where
    ({{#apis}}{{#operations}}{{#operation}}(coerce -> {{operationId}}){{#hasMore}} :<|>
     {{/hasMore}}{{/operation}}{{/operations}}{{#hasMore}} :<|>
     {{/hasMore}}{{/apis}}) = hoistClient proxy liftClient (client proxy)
    proxy = (Proxy :: Proxy {{title}}API)

-- | Run requests in the {{title}}Client monad.
run{{title}}Client :: ServerConfig -> {{title}}Client a -> ClientM a
run{{title}}Client clientConfig cl = do
  manager <- liftIO $ newManager defaultManagerSettings
  run{{title}}ClientWithManager manager clientConfig cl

-- | Run requests in the {{title}}Client monad using a custom manager.
run{{title}}ClientWithManager :: Manager -> ServerConfig -> {{title}}Client a -> ClientM a
run{{title}}ClientWithManager manager clientConfig cl =
  runClient cl manager $ BaseUrl Http (configHost clientConfig) (configPort clientConfig) ""

-- | Run the {{title}} server at the provided host and port.
run{{title}}Server :: MonadIO m => ServerConfig -> {{title}}Backend Handler -> m ()
run{{title}}Server ServerConfig{..} backend =
  liftIO $ Warp.runSettings warpSettings $ serve (Proxy :: Proxy {{title}}API) (serverFromBackend backend)
  where
    warpSettings = Warp.defaultSettings & Warp.setPort configPort & Warp.setHost (fromString configHost)
    serverFromBackend {{title}}Backend{..} =
      ({{#apis}}{{#operations}}{{#operation}}coerce {{operationId}}{{#hasMore}} :<|>
       {{/hasMore}}{{/operation}}{{/operations}}{{#hasMore}} :<|>
       {{/hasMore}}{{/apis}})
{{/apiInfo}}
